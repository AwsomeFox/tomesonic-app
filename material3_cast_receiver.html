<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audiobookshelf Cast Receiver</title>

    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Material 3 Color Tokens - Dark Theme */
            --md-sys-color-primary: #90CAF9;
            --md-sys-color-on-primary: #003258;
            --md-sys-color-primary-container: #004881;
            --md-sys-color-on-primary-container: #D1E4FF;

            --md-sys-color-secondary: #BCC7DB;
            --md-sys-color-on-secondary: #26304B;
            --md-sys-color-secondary-container: #3C4663;
            --md-sys-color-on-secondary-container: #D8E3F8;

            --md-sys-color-surface: #121316;
            --md-sys-color-surface-dim: #121316;
            --md-sys-color-surface-bright: #38393C;
            --md-sys-color-surface-container-lowest: #0D0E11;
            --md-sys-color-surface-container-low: #1A1C1E;
            --md-sys-color-surface-container: #1E2022;
            --md-sys-color-surface-container-high: #282A2C;
            --md-sys-color-surface-container-highest: #333537;

            --md-sys-color-on-surface: #E3E2E6;
            --md-sys-color-on-surface-variant: #C4C7C5;
            --md-sys-color-outline: #8E918F;
            --md-sys-color-outline-variant: #444746;

            --md-sys-color-error: #FFB4AB;
            --md-sys-color-on-error: #690005;
            --md-sys-color-error-container: #93000A;
            --md-sys-color-on-error-container: #FFDAD6;

            /* Typography Scale */
            --md-sys-typescale-display-large-font-size: 57px;
            --md-sys-typescale-display-large-line-height: 64px;
            --md-sys-typescale-display-large-font-weight: 400;

            --md-sys-typescale-headline-large-font-size: 32px;
            --md-sys-typescale-headline-large-line-height: 40px;
            --md-sys-typescale-headline-large-font-weight: 400;

            --md-sys-typescale-headline-medium-font-size: 28px;
            --md-sys-typescale-headline-medium-line-height: 36px;
            --md-sys-typescale-headline-medium-font-weight: 400;

            --md-sys-typescale-title-large-font-size: 22px;
            --md-sys-typescale-title-large-line-height: 28px;
            --md-sys-typescale-title-large-font-weight: 400;

            --md-sys-typescale-body-large-font-size: 16px;
            --md-sys-typescale-body-large-line-height: 24px;
            --md-sys-typescale-body-large-font-weight: 400;

            --md-sys-typescale-body-medium-font-size: 14px;
            --md-sys-typescale-body-medium-line-height: 20px;
            --md-sys-typescale-body-medium-font-weight: 400;

            --md-sys-typescale-label-large-font-size: 14px;
            --md-sys-typescale-label-large-line-height: 20px;
            --md-sys-typescale-label-large-font-weight: 500;

            /* Elevation */
            --md-sys-elevation-level0: none;
            --md-sys-elevation-level1: 0px 1px 3px 1px rgba(0, 0, 0, 0.15), 0px 1px 2px 0px rgba(0, 0, 0, 0.30);
            --md-sys-elevation-level2: 0px 2px 6px 2px rgba(0, 0, 0, 0.15), 0px 1px 2px 0px rgba(0, 0, 0, 0.30);
            --md-sys-elevation-level3: 0px 4px 8px 3px rgba(0, 0, 0, 0.15), 0px 1px 3px 0px rgba(0, 0, 0, 0.30);
            --md-sys-elevation-level4: 0px 6px 10px 4px rgba(0, 0, 0, 0.15), 0px 2px 3px 0px rgba(0, 0, 0, 0.30);
            --md-sys-elevation-level5: 0px 8px 12px 6px rgba(0, 0, 0, 0.15), 0px 4px 4px 0px rgba(0, 0, 0, 0.30);

            /* Animation */
            --md-sys-motion-duration-short1: 50ms;
            --md-sys-motion-duration-short2: 100ms;
            --md-sys-motion-duration-short3: 150ms;
            --md-sys-motion-duration-short4: 200ms;
            --md-sys-motion-duration-medium1: 250ms;
            --md-sys-motion-duration-medium2: 300ms;
            --md-sys-motion-duration-medium3: 350ms;
            --md-sys-motion-duration-medium4: 400ms;
            --md-sys-motion-duration-long1: 450ms;
            --md-sys-motion-duration-long2: 500ms;
            --md-sys-motion-duration-long3: 550ms;
            --md-sys-motion-duration-long4: 600ms;

            --md-sys-motion-easing-emphasized: cubic-bezier(0.2, 0, 0, 1);
            --md-sys-motion-easing-standard: cubic-bezier(0.2, 0, 0, 1);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Main Container */
        .receiver-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
            gap: 24px;
        }

        /* Media Card */
        .media-card {
            background: var(--md-sys-color-surface-container);
            border-radius: 28px;
            padding: 32px;
            box-shadow: var(--md-sys-elevation-level2);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: all var(--md-sys-motion-duration-medium2) var(--md-sys-motion-easing-standard);
        }

        /* Cover Art */
        .cover-art {
            width: 280px;
            height: 280px;
            border-radius: 20px;
            background: var(--md-sys-color-surface-container-high);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 24px;
            overflow: hidden;
            box-shadow: var(--md-sys-elevation-level3);
            transition: transform var(--md-sys-motion-duration-medium2) var(--md-sys-motion-easing-standard);
        }

        .cover-art:hover {
            transform: scale(1.02);
        }

        .cover-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 20px;
        }

        .cover-art .placeholder {
            font-size: 64px;
            color: var(--md-sys-color-on-surface-variant);
            opacity: 0.6;
        }

        /* Typography */
        .book-title {
            font-size: var(--md-sys-typescale-headline-large-font-size);
            line-height: var(--md-sys-typescale-headline-large-line-height);
            font-weight: var(--md-sys-typescale-headline-large-font-weight);
            color: var(--md-sys-color-on-surface);
            margin: 0 0 8px 0;
            text-align: center;
        }

        .book-author {
            font-size: var(--md-sys-typescale-title-large-font-size);
            line-height: var(--md-sys-typescale-title-large-line-height);
            font-weight: var(--md-sys-typescale-title-large-font-weight);
            color: var(--md-sys-color-on-surface-variant);
            margin: 0 0 16px 0;
        }

        .chapter-title {
            font-size: var(--md-sys-typescale-body-large-font-size);
            line-height: var(--md-sys-typescale-body-large-line-height);
            font-weight: 500;
            color: var(--md-sys-color-primary);
            margin: 0;
            padding: 8px 16px;
            background: var(--md-sys-color-primary-container);
            border-radius: 16px;
            display: inline-block;
        }

        /* Progress Section */
        .progress-section {
            width: 100%;
            margin-top: 32px;
            gap: 16px;
            display: flex;
            flex-direction: column;
        }

        .progress-container {
            width: 100%;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: var(--md-sys-typescale-body-medium-font-size);
            font-weight: 500;
            color: var(--md-sys-color-on-surface-variant);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--md-sys-color-outline-variant);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: var(--md-sys-color-primary);
            border-radius: 4px;
            transition: width var(--md-sys-motion-duration-medium2) var(--md-sys-motion-easing-standard);
            width: 0%;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: var(--md-sys-typescale-body-medium-font-size);
            color: var(--md-sys-color-on-surface-variant);
            font-variant-numeric: tabular-nums;
        }

        /* Status Chip */
        .status-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 16px;
            font-size: var(--md-sys-typescale-label-large-font-size);
            font-weight: var(--md-sys-typescale-label-large-font-weight);
            transition: all var(--md-sys-motion-duration-short4) var(--md-sys-motion-easing-standard);
            margin-top: 16px;
        }

        .status-chip.playing {
            background: rgba(76, 175, 80, 0.16);
            color: #4CAF50;
        }

        .status-chip.paused {
            background: rgba(255, 152, 0, 0.16);
            color: #FF9800;
        }

        .status-chip.loading {
            background: rgba(33, 150, 243, 0.16);
            color: #2196F3;
        }

        .status-chip.error {
            background: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }

        .status-chip .material-icons {
            font-size: 18px;
        }

        /* Chapter Queue */
        .chapter-queue {
            flex: 1;
            background: var(--md-sys-color-surface-container);
            border-radius: 28px;
            padding: 24px;
            box-shadow: var(--md-sys-elevation-level2);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chapter-queue-header {
            font-size: var(--md-sys-typescale-title-large-font-size);
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
            margin: 0 0 16px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chapter-list {
            flex: 1;
            overflow-y: auto;
            margin: 0 -24px;
            padding: 0 24px;
        }

        .chapter-list::-webkit-scrollbar {
            width: 8px;
        }

        .chapter-list::-webkit-scrollbar-track {
            background: var(--md-sys-color-surface-container-high);
            border-radius: 4px;
        }

        .chapter-list::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-outline);
            border-radius: 4px;
        }

        .chapter-list::-webkit-scrollbar-thumb:hover {
            background: var(--md-sys-color-on-surface-variant);
        }

        .chapter-item {
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 16px;
            transition: all var(--md-sys-motion-duration-short4) var(--md-sys-motion-easing-standard);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .chapter-item:hover {
            background: var(--md-sys-color-surface-container-high);
        }

        .chapter-item.current {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
        }

        .chapter-item.current::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--md-sys-color-primary);
        }

        .chapter-number {
            font-size: var(--md-sys-typescale-label-large-font-size);
            font-weight: 700;
            color: var(--md-sys-color-primary);
            min-width: 32px;
            text-align: center;
            background: var(--md-sys-color-surface-container-highest);
            border-radius: 8px;
            padding: 4px 8px;
        }

        .chapter-item.current .chapter-number {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }

        .chapter-info {
            flex: 1;
            min-width: 0;
        }

        .chapter-name {
            font-size: var(--md-sys-typescale-body-large-font-size);
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chapter-item.current .chapter-name {
            color: var(--md-sys-color-on-primary-container);
        }

        .chapter-duration {
            font-size: var(--md-sys-typescale-body-medium-font-size);
            color: var(--md-sys-color-on-surface-variant);
            margin: 4px 0 0 0;
            font-variant-numeric: tabular-nums;
        }

        .chapter-item.current .chapter-duration {
            color: var(--md-sys-color-on-primary-container);
            opacity: 0.8;
        }

        /* Debug Panel */
        .debug-panel {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 400px;
            max-height: 300px;
            background: var(--md-sys-color-surface-container-highest);
            border-radius: 16px;
            padding: 16px;
            box-shadow: var(--md-sys-elevation-level5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: all var(--md-sys-motion-duration-medium2) var(--md-sys-motion-easing-standard);
        }

        .debug-panel.collapsed {
            height: 56px;
        }

        .debug-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .debug-title {
            font-size: var(--md-sys-typescale-body-large-font-size);
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
        }

        .debug-toggle {
            background: none;
            border: none;
            color: var(--md-sys-color-primary);
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background var(--md-sys-motion-duration-short2);
        }

        .debug-toggle:hover {
            background: rgba(144, 202, 249, 0.08);
        }

        .debug-log {
            flex: 1;
            overflow-y: auto;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .debug-log::-webkit-scrollbar {
            width: 6px;
        }

        .debug-log::-webkit-scrollbar-track {
            background: transparent;
        }

        .debug-log::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-outline);
            border-radius: 3px;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
            word-break: break-word;
        }

        .log-entry.info { color: var(--md-sys-color-on-surface); }
        .log-entry.success { color: #4CAF50; }
        .log-entry.warning { color: #FF9800; }
        .log-entry.error { color: var(--md-sys-color-error); }

        /* Responsive Design */
        @media (max-width: 768px) {
            .receiver-container {
                padding: 16px;
                gap: 16px;
            }

            .media-card {
                padding: 24px;
            }

            .cover-art {
                width: 200px;
                height: 200px;
            }

            .book-title {
                font-size: 24px;
                line-height: 32px;
            }

            .debug-panel {
                width: calc(100vw - 32px);
                bottom: 16px;
                right: 16px;
            }
        }

        @media (orientation: landscape) and (max-height: 600px) {
            .receiver-container {
                flex-direction: row;
                gap: 24px;
            }

            .media-card {
                flex: 1;
                max-width: 50%;
            }

            .chapter-queue {
                flex: 1;
                max-width: 50%;
            }

            .cover-art {
                width: 200px;
                height: 200px;
            }
        }

        /* Loading Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 2s infinite;
        }

        /* Ripple Effect */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .ripple:active::before {
            width: 300px;
            height: 300px;
        }
    </style>
</head>
<body>
    <div class="receiver-container">
        <!-- Main Media Card -->
        <div class="media-card">
            <div class="cover-art" id="cover-art">
                <div class="placeholder material-icons">headphones</div>
            </div>

            <h1 class="book-title" id="book-title">Audiobookshelf Cast Receiver</h1>
            <h2 class="book-author" id="book-author">Ready for content</h2>
            <div class="chapter-title" id="chapter-title">Waiting for media...</div>

            <div class="progress-section">
                <!-- Chapter Progress -->
                <div class="progress-container">
                    <div class="progress-label">
                        <span>Chapter Progress</span>
                        <span id="chapter-progress-text">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="chapter-progress-fill"></div>
                    </div>
                    <div class="time-display">
                        <span id="chapter-current-time">0:00:00</span>
                        <span id="chapter-duration">0:00:00</span>
                    </div>
                </div>

                <!-- Book Progress -->
                <div class="progress-container">
                    <div class="progress-label">
                        <span>Book Progress</span>
                        <span id="book-progress-text">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="book-progress-fill"></div>
                    </div>
                    <div class="time-display">
                        <span id="book-current-time">0:00:00</span>
                        <span id="book-duration">0:00:00</span>
                    </div>
                </div>
            </div>

            <div class="status-chip" id="status-chip">
                <span class="material-icons">cast</span>
                <span id="status-text">Initializing...</span>
            </div>
        </div>

        <!-- Chapter Queue -->
        <div class="chapter-queue" id="chapter-queue" style="display: none;">
            <div class="chapter-queue-header">
                <span class="material-icons">list</span>
                <span>Chapters</span>
                <span id="chapter-count"></span>
            </div>
            <div class="chapter-list" id="chapter-list">
                <!-- Chapter items will be populated here -->
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel collapsed" id="debug-panel">
        <div class="debug-header" onclick="toggleDebugPanel()">
            <span class="debug-title">Debug Log</span>
            <button class="debug-toggle">
                <span class="material-icons" id="debug-toggle-icon">expand_less</span>
            </button>
        </div>
        <div class="debug-log" id="debug-log">
            <div class="log-entry info">üöÄ Material 3 Cast Receiver initializing...</div>
        </div>
    </div>

    <!-- Cast Receiver SDK -->
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <script>
        class AudiobookCastReceiver {
            constructor() {
                this.playerManager = null;
                this.context = null;
                this.mediaQueue = [];
                this.currentQueueIndex = 0;
                this.bookMetadata = {};
                this.chapterData = {};
                this.debugCollapsed = true;

                // ABSOLUTE TIMELINE TRACKING - Fixes chapter-relative vs absolute seeking mismatch
                this.absoluteTimelineMs = 0;       // Current absolute book position
                this.chapterStartTimes = [];       // Cumulative start times for each chapter
                this.totalBookDurationMs = 0;      // Total duration of entire book
                this.currentChapterDurationMs = 0; // Duration of current chapter

                this.init();
            }

            init() {
                this.log('üé¨ Initializing Material 3 Cast Receiver...', 'info');
                this.updateStatus('Initializing...', 'loading');

                // Check if Cast framework is available
                if (typeof cast === 'undefined' || !cast.framework) {
                    this.log('‚ùå Cast framework not available', 'error');
                    this.updateStatus('Cast framework not loaded', 'error');
                    return;
                }

                try {
                    // Log framework version if available
                    if (cast.framework.VERSION) {
                        this.log(`üì± Cast framework version: ${cast.framework.VERSION}`, 'info');
                    }

                    this.context = cast.framework.CastReceiverContext.getInstance();
                    this.playerManager = this.context.getPlayerManager();

                    if (!this.context || !this.playerManager) {
                        throw new Error('Failed to get Cast context or player manager');
                    }

                    // Log available event types for debugging
                    if (cast?.framework?.events) {
                        this.log(`üîç Available events object keys: ${Object.keys(cast.framework.events)}`, 'info');
                        if (cast.framework.events.EventType) {
                            this.log(`üîç EventType keys: ${Object.keys(cast.framework.events.EventType)}`, 'info');
                        }
                    }

                    this.setupMessageInterceptors();
                    this.setupEventListeners();
                    this.setupPlaybackConfig();

                    this.context.start();
                    this.log('‚úÖ Cast receiver started successfully', 'success');
                    this.updateStatus('Ready for casting', 'info');

                } catch (error) {
                    this.log(`‚ùå Failed to initialize: ${error.message}`, 'error');
                    this.updateStatus('Initialization failed', 'error');

                    // Log additional debug information
                    this.log(`üîç Cast object available: ${typeof cast !== 'undefined'}`, 'info');
                    this.log(`üîç Framework available: ${typeof cast?.framework !== 'undefined'}`, 'info');
                    this.log(`üîç Events available: ${typeof cast?.framework?.events !== 'undefined'}`, 'info');

                    // Log available event types for debugging
                    if (cast?.framework?.events) {
                        this.log(`üîç Available events object keys: ${Object.keys(cast.framework.events)}`, 'info');
                        if (cast.framework.events.EventType) {
                            this.log(`üîç EventType keys: ${Object.keys(cast.framework.events.EventType)}`, 'info');
                        }
                    }

                    // Fallback: Try basic initialization without advanced features
                    this.log(`üîÑ Attempting basic fallback initialization...`, 'info');
                    try {
                        this.context = cast.framework.CastReceiverContext.getInstance();
                        this.playerManager = this.context.getPlayerManager();

                        // Start with minimal configuration
                        this.context.start();
                        this.log(`‚úÖ Basic fallback initialization successful`, 'success');
                        this.updateStatus('Basic receiver ready', 'info');
                    } catch (fallbackError) {
                        this.log(`‚ùå Fallback initialization also failed: ${fallbackError.message}`, 'error');
                        this.updateStatus('Complete failure', 'error');
                    }
                }
            }

            setupPlaybackConfig() {
                try {
                    const playbackConfig = new cast.framework.PlaybackConfig();

                    // Set supported commands safely
                    if (cast.framework.messages && cast.framework.messages.Command) {
                        playbackConfig.supportedCommands =
                            cast.framework.messages.Command.ALL_BASIC_MEDIA |
                            cast.framework.messages.Command.QUEUE_NEXT |
                            cast.framework.messages.Command.QUEUE_PREV |
                            cast.framework.messages.Command.SEEK;
                    }

                    playbackConfig.autoResumeDuration = 5;

                    // Check if setPlaybackConfig exists on context or playerManager
                    if (typeof this.context.setPlaybackConfig === 'function') {
                        this.context.setPlaybackConfig(playbackConfig);
                        this.log('‚öôÔ∏è Playback configuration set on context', 'info');
                    } else if (typeof this.playerManager.setPlaybackConfig === 'function') {
                        this.playerManager.setPlaybackConfig(playbackConfig);
                        this.log('‚öôÔ∏è Playback configuration set on playerManager', 'info');
                    } else {
                        this.log('‚ö†Ô∏è setPlaybackConfig not available, using defaults', 'warning');
                    }
                } catch (error) {
                    this.log(`‚ö†Ô∏è Failed to set playback config: ${error.message}`, 'warning');
                }
            }

            setupMessageInterceptors() {
                // LOAD Message Interceptor
                this.playerManager.setMessageInterceptor(
                    cast.framework.messages.MessageType.LOAD,
                    (loadRequest) => this.handleLoadRequest(loadRequest)
                );

                // QUEUE_LOAD Message Interceptor
                this.playerManager.setMessageInterceptor(
                    cast.framework.messages.MessageType.QUEUE_LOAD,
                    (queueLoadRequest) => this.handleQueueLoadRequest(queueLoadRequest)
                );

                // QUEUE_UPDATE Message Interceptor
                this.playerManager.setMessageInterceptor(
                    cast.framework.messages.MessageType.QUEUE_UPDATE,
                    (queueUpdateRequest) => this.handleQueueUpdateRequest(queueUpdateRequest)
                );

                // SEEK Message Interceptor - CRITICAL FIX for absolute vs chapter-relative seeking
                this.playerManager.setMessageInterceptor(
                    cast.framework.messages.MessageType.SEEK,
                    (seekRequest) => this.handleSeekRequest(seekRequest)
                );

                this.log('üì® Message interceptors configured', 'info');
            }

            setupEventListeners() {
                // Helper function to safely add event listeners
                const safeAddEventListener = (eventType, handler, description) => {
                    try {
                        if (eventType && typeof eventType === 'string') {
                            this.playerManager.addEventListener(eventType, handler);
                            this.log(`‚úÖ ${description} listener added`, 'info');
                        } else {
                            this.log(`‚ö†Ô∏è Skipping ${description} - event type undefined`, 'warning');
                        }
                    } catch (error) {
                        this.log(`‚ùå Failed to add ${description} listener: ${error.message}`, 'error');
                    }
                };

                // Map our desired events to actual Cast SDK v3 event types
                const eventTypeMap = {
                    'PLAYER_LOAD_COMPLETE': 'PLAYER_LOAD_COMPLETE',  // Available
                    'PLAYING': 'PLAYING',                            // Available
                    'PAUSED': 'PAUSE',                               // Use PAUSE instead of PAUSED
                    'IDLE': 'ENDED',                                 // Use ENDED instead of IDLE
                    'TIME_UPDATE': 'TIME_UPDATE',                    // Available
                    'QUEUE_CHANGE': 'REQUEST_QUEUE_UPDATE',          // Use queue request event
                    'ERROR': 'ERROR'                                 // Available
                };

                // Get the actual event type from Cast SDK
                const getEventType = (eventName) => {
                    const mappedName = eventTypeMap[eventName];
                    return cast.framework.events?.EventType?.[mappedName] || mappedName;
                };

                // Media Load Complete
                safeAddEventListener(
                    getEventType('PLAYER_LOAD_COMPLETE'),
                    () => this.handleMediaLoadComplete(),
                    'Media Load Complete'
                );

                // Playback State Changes
                safeAddEventListener(
                    getEventType('PLAYING'),
                    () => this.handlePlaybackState('playing'),
                    'Player Playing'
                );

                safeAddEventListener(
                    getEventType('PAUSED'),
                    () => this.handlePlaybackState('paused'),
                    'Player Paused'
                );

                safeAddEventListener(
                    getEventType('IDLE'),
                    (event) => this.handlePlayerIdle(event),
                    'Player Idle'
                );

                // Additional useful events
                safeAddEventListener(
                    cast.framework.events?.EventType?.MEDIA_STATUS,
                    (event) => this.handleMediaStatus(event),
                    'Media Status'
                );

                safeAddEventListener(
                    cast.framework.events?.EventType?.MEDIA_INFORMATION_CHANGED,
                    (event) => this.handleMediaInformationChanged(event),
                    'Media Information Changed'
                );

                // Time Updates
                safeAddEventListener(
                    getEventType('TIME_UPDATE'),
                    () => this.handleTimeUpdate(),
                    'Time Update'
                );

                // Queue Changes
                safeAddEventListener(
                    getEventType('QUEUE_CHANGE'),
                    (event) => this.handleQueueChange(event),
                    'Queue Change'
                );

                // Errors
                safeAddEventListener(
                    getEventType('ERROR'),
                    (errorEvent) => this.handleError(errorEvent),
                    'Error'
                );

                this.log('üëÇ Event listeners configuration completed', 'info');
            }

            handleLoadRequest(loadRequest) {
                this.log('üì• LOAD request received', 'info');
                this.log(`üì± Content ID: ${loadRequest.media.contentId}`, 'info');
                this.log(`üì± Content Type: ${loadRequest.media.contentType}`, 'info');
                this.log(`üì± Stream Type: ${loadRequest.media.streamType}`, 'info');

                // Basic validation - ensure we have a valid URL
                if (!loadRequest.media.contentId) {
                    this.log(`‚ùå No content ID provided`, 'error');
                    this.updateStatus('Invalid media', 'error');
                    return loadRequest;
                }

                // Test URL accessibility
                this.log(`üîó Testing URL accessibility: ${loadRequest.media.contentId}`, 'info');

                if (loadRequest.media.customData) {
                    this.log(`üìä Custom Data: ${JSON.stringify(loadRequest.media.customData, null, 2)}`, 'info');
                    this.extractChapterData(loadRequest.media);

                    // Ensure proper content type for audio files
                    if (!loadRequest.media.contentType || loadRequest.media.contentType === 'application/x-mpegURL') {
                        loadRequest.media.contentType = 'audio/mpeg';
                        this.log(`üîß Set content type to audio/mpeg`, 'info');
                    }
                } else {
                    this.log(`‚ö†Ô∏è No custom data - using basic playback mode`, 'warning');
                    // Ensure basic content type
                    if (!loadRequest.media.contentType) {
                        loadRequest.media.contentType = 'audio/mpeg';
                        this.log(`üîß Set default content type to audio/mpeg`, 'info');
                    }
                }

                this.updateMediaDisplay(loadRequest.media);
                this.updateStatus('Loading media...', 'loading');

                return loadRequest;
            }

            handleQueueLoadRequest(queueLoadRequest) {
                this.log('üìã QUEUE_LOAD request received', 'info');
                this.log(`üì± Queue items: ${queueLoadRequest.items.length}`, 'info');

                // Log queue items for debugging
                queueLoadRequest.items.forEach((queueItem, index) => {
                    const media = queueItem.media;
                    this.log(`üì± Item ${index}: ${media.contentId}`, 'info');

                    if (media.customData) {
                        this.log(`üìä Item ${index} Custom Data: ${JSON.stringify(media.customData, null, 2)}`, 'info');

                        // Ensure proper content type for audio files
                        if (!media.contentType || media.contentType === 'application/x-mpegURL') {
                            media.contentType = 'audio/mpeg';
                        }
                    }
                });

                this.mediaQueue = queueLoadRequest.items;
                this.currentQueueIndex = queueLoadRequest.startIndex || 0;

                // Extract book metadata from first item
                if (this.mediaQueue.length > 0) {
                    const firstItem = this.mediaQueue[0];
                    this.extractBookMetadata(firstItem.media);
                    this.buildChapterQueue();
                }

                this.log(`üìö Book has ${this.mediaQueue.length} chapters`, 'success');
                this.updateChapterDisplay();

                return queueLoadRequest;
            }

            handleQueueUpdateRequest(queueUpdateRequest) {
                this.log('üìù QUEUE_UPDATE request received', 'info');

                if (queueUpdateRequest.currentIndex !== undefined) {
                    this.currentQueueIndex = queueUpdateRequest.currentIndex;
                    this.updateChapterDisplay();
                }

                return queueUpdateRequest;
            }

            // CRITICAL FIX: Handle absolute seeking from Android app
            handleSeekRequest(seekRequest) {
                const requestedTime = seekRequest.currentTime;
                this.log(`üéØ SEEK request: ${requestedTime}s (${Math.round(requestedTime * 1000)}ms)`, 'info');

                // Safety check - if we don't have chapter data yet, pass through the seek as-is
                if (!this.chapterStartTimes || this.chapterStartTimes.length === 0 || !this.mediaQueue || this.mediaQueue.length === 0) {
                    this.log(`‚ö†Ô∏è No chapter data available yet - passing seek through as-is`, 'warning');
                    return seekRequest;
                }

                // For single chapter or basic media, just pass through
                if (this.mediaQueue.length === 1) {
                    this.log(`üì± Single chapter - passing seek through as-is`, 'info');
                    return seekRequest;
                }

                // Convert absolute book position to chapter + chapter-relative position
                const result = this.convertAbsoluteToChapterPosition(requestedTime * 1000);

                if (result) {
                    this.log(`üîÑ Converting absolute ${requestedTime}s to Chapter ${result.chapterIndex + 1} at ${result.chapterRelativeSeconds}s`, 'info');

                    // If we need to change chapters, jump to the target chapter first
                    if (result.chapterIndex !== this.currentQueueIndex) {
                        this.log(`‚è≠Ô∏è Switching from chapter ${this.currentQueueIndex + 1} to ${result.chapterIndex + 1}`, 'info');

                        // Update current chapter index
                        this.currentQueueIndex = result.chapterIndex;

                        // Jump to the target chapter, then seek within it
                        const queueJumpRequest = new cast.framework.messages.QueueJumpRequest();
                        queueJumpRequest.currentIndex = result.chapterIndex;

                        // Store the target seek position for after chapter switch
                        this.pendingSeekSeconds = result.chapterRelativeSeconds;

                        this.playerManager.getQueueManager().queueJump(queueJumpRequest);

                        // Don't seek immediately - let chapter switch complete first
                        seekRequest.currentTime = 0; // Start at beginning of chapter for now
                    } else {
                        // Same chapter, just seek within it
                        seekRequest.currentTime = result.chapterRelativeSeconds;
                    }

                    this.updateChapterDisplay();
                } else {
                    this.log(`‚ö†Ô∏è Could not convert absolute time ${requestedTime}s to chapter position - passing through`, 'warning');
                }

                return seekRequest;
            }

            // Convert absolute book time to chapter index and chapter-relative time
            convertAbsoluteToChapterPosition(absoluteTimeMs) {
                if (!this.chapterStartTimes || this.chapterStartTimes.length === 0) {
                    this.log('‚ö†Ô∏è No chapter start times available for conversion', 'warning');
                    return null;
                }

                // Find which chapter contains this absolute time
                for (let i = 0; i < this.chapterStartTimes.length; i++) {
                    const chapterStartMs = this.chapterStartTimes[i];
                    const nextChapterStartMs = this.chapterStartTimes[i + 1] || this.totalBookDurationMs;

                    if (absoluteTimeMs >= chapterStartMs && absoluteTimeMs < nextChapterStartMs) {
                        const chapterRelativeMs = absoluteTimeMs - chapterStartMs;
                        return {
                            chapterIndex: i,
                            chapterRelativeMs: chapterRelativeMs,
                            chapterRelativeSeconds: chapterRelativeMs / 1000
                        };
                    }
                }

                // If beyond the last chapter, put it at the end of the last chapter
                if (absoluteTimeMs >= this.totalBookDurationMs) {
                    const lastChapterIndex = this.chapterStartTimes.length - 1;
                    const lastChapterStartMs = this.chapterStartTimes[lastChapterIndex];
                    const lastChapterDurationMs = this.totalBookDurationMs - lastChapterStartMs;

                    return {
                        chapterIndex: lastChapterIndex,
                        chapterRelativeMs: lastChapterDurationMs,
                        chapterRelativeSeconds: lastChapterDurationMs / 1000
                    };
                }

                return null;
            }

            extractBookMetadata(mediaInfo) {
                if (!mediaInfo || !mediaInfo.metadata) return;

                this.bookMetadata = {
                    title: mediaInfo.metadata.albumTitle || mediaInfo.metadata.title || 'Unknown Book',
                    author: mediaInfo.metadata.artist || mediaInfo.metadata.albumArtist || 'Unknown Author',
                    coverUrl: mediaInfo.metadata.images?.[0]?.url || null
                };

                this.log(`üìñ Book: "${this.bookMetadata.title}" by ${this.bookMetadata.author}`, 'info');
            }

            extractChapterData(mediaInfo) {
                if (!mediaInfo || !mediaInfo.customData) return;

                const customData = mediaInfo.customData;
                this.chapterData = {
                    startMs: customData.startMs || 0,
                    endMs: customData.endMs || 0,
                    isChapter: customData.isChapter || false,
                    trackNumber: customData.trackNumber || 1,
                    totalTracks: customData.totalTracks || 1,
                    chapterTitle: mediaInfo.metadata?.title || `Chapter ${customData.trackNumber}`
                };

                this.log(`üìë Chapter: ${this.chapterData.chapterTitle} (${this.chapterData.trackNumber}/${this.chapterData.totalTracks})`, 'info');
            }

            buildChapterQueue() {
                const chapterList = document.getElementById('chapter-list');
                chapterList.innerHTML = '';

                // CALCULATE ABSOLUTE TIMELINE - This fixes seeking to work across chapters
                this.chapterStartTimes = [];
                let cumulativeTime = 0;
                this.totalBookDurationMs = 0;

                this.mediaQueue.forEach((queueItem, index) => {
                    const media = queueItem.media;
                    const customData = media.customData || {};
                    const chapterTitle = media.metadata?.title || `Chapter ${index + 1}`;

                    // Calculate absolute start time for this chapter
                    this.chapterStartTimes[index] = cumulativeTime;

                    // Get chapter duration from clipping data or stream duration
                    let chapterDurationMs = 0;
                    if (customData.startMs !== undefined && customData.endMs !== undefined) {
                        chapterDurationMs = customData.endMs - customData.startMs;
                    } else {
                        // Fallback to stream duration if no clipping data
                        chapterDurationMs = media.streamDuration || 0;
                    }

                    cumulativeTime += chapterDurationMs;

                    const chapterElement = document.createElement('div');
                    chapterElement.className = `chapter-item ripple ${index === this.currentQueueIndex ? 'current' : ''}`;
                    chapterElement.onclick = () => this.jumpToChapter(index);

                    const duration = this.formatDuration(chapterDurationMs / 1000);

                    chapterElement.innerHTML = `
                        <div class="chapter-number">${index + 1}</div>
                        <div class="chapter-info">
                            <div class="chapter-name">${chapterTitle}</div>
                            <div class="chapter-duration">${duration}</div>
                        </div>
                    `;

                    chapterList.appendChild(chapterElement);
                });

                this.totalBookDurationMs = cumulativeTime;

                document.getElementById('chapter-count').textContent = `(${this.mediaQueue.length})`;
                document.getElementById('chapter-queue').style.display = 'flex';

                this.log(`üìë Generated chapter list with ${this.mediaQueue.length} items`, 'success');
                this.log(`üìä Total book duration: ${this.formatDuration(this.totalBookDurationMs / 1000)}`, 'info');
                this.log(`üìç Chapter start times calculated: ${this.chapterStartTimes.map(t => Math.round(t/1000))}s`, 'info');
            }

            jumpToChapter(index) {
                if (index >= 0 && index < this.mediaQueue.length) {
                    this.log(`‚è≠Ô∏è Jumping to chapter ${index + 1}`, 'info');

                    const queueJumpRequest = new cast.framework.messages.QueueJumpRequest();
                    queueJumpRequest.currentIndex = index;

                    this.playerManager.getQueueManager().queueJump(queueJumpRequest);
                }
            }

            handleMediaLoadComplete() {
                this.log('‚úÖ Media loaded successfully', 'success');
                this.updateStatus('Media loaded', 'success');

                const mediaInfo = this.playerManager.getMediaInformation();
                if (mediaInfo) {
                    this.updateMediaDisplay(mediaInfo);
                    this.extractChapterData(mediaInfo);

                    // Handle chapter seeking if this is a chapter with start time
                    if (mediaInfo.customData &&
                        mediaInfo.customData.isChapter &&
                        mediaInfo.customData.startMs !== undefined &&
                        mediaInfo.customData.startMs > 0) {

                        const seekTimeSeconds = mediaInfo.customData.startMs / 1000;
                        this.log(`üéØ Chapter starts at ${seekTimeSeconds}s, seeking...`, 'info');

                        // Seek to chapter start time
                        setTimeout(() => {
                            try {
                                this.playerManager.seek(seekTimeSeconds);
                                this.log(`‚úÖ Seeked to chapter start: ${seekTimeSeconds}s`, 'success');
                            } catch (error) {
                                this.log(`‚ùå Failed to seek to chapter start: ${error.message}`, 'error');
                            }
                        }, 500); // Small delay to ensure media is ready
                    }
                }

                // Handle pending seek from absolute timeline conversion
                if (this.pendingSeekSeconds !== undefined) {
                    this.log(`üéØ Executing pending seek to ${this.pendingSeekSeconds}s after chapter switch`, 'info');

                    setTimeout(() => {
                        try {
                            this.playerManager.seek(this.pendingSeekSeconds);
                            this.log(`‚úÖ Completed pending seek to ${this.pendingSeekSeconds}s`, 'success');
                            this.pendingSeekSeconds = undefined; // Clear pending seek
                        } catch (error) {
                            this.log(`‚ùå Failed pending seek: ${error.message}`, 'error');
                        }
                    }, 800); // Longer delay for chapter switch
                }

                // Update chapter highlighting
                this.updateChapterDisplay();
            }

            handlePlaybackState(state) {
                const stateEmojis = {
                    'playing': '‚ñ∂Ô∏è',
                    'paused': '‚è∏Ô∏è'
                };

                this.log(`${stateEmojis[state]} Playback ${state}`, 'info');
                this.updateStatus(state.charAt(0).toUpperCase() + state.slice(1), state);

                if (state === 'playing') {
                    this.startProgressUpdates();
                } else {
                    this.stopProgressUpdates();
                }
            }

            handlePlayerIdle(event) {
                this.log(`‚èπÔ∏è Player idle: ${event.idleReason}`, 'info');
                this.updateStatus('Idle', 'info');
                this.stopProgressUpdates();
            }

            handleTimeUpdate() {
                this.updateProgressBars();
            }

            handleQueueChange(event) {
                this.log(`üìã Queue changed: ${event.type}`, 'info');

                const queueManager = this.playerManager.getQueueManager();
                if (queueManager) {
                    const currentIndex = queueManager.getCurrentIndex();

                    if (currentIndex !== this.currentQueueIndex && currentIndex >= 0) {
                        this.currentQueueIndex = currentIndex;
                        this.updateChapterDisplay();

                        // Update current chapter metadata
                        if (this.mediaQueue[currentIndex]) {
                            const currentMedia = this.mediaQueue[currentIndex].media;
                            this.extractChapterData(currentMedia);
                            this.updateCurrentChapterTitle();
                        }
                    }
                }
            }

            handleMediaStatus(event) {
                this.log(`üìä Media status event: ${event.mediaStatus?.playerState}`, 'info');

                if (event.mediaStatus) {
                    const playerState = event.mediaStatus.playerState;

                    switch (playerState) {
                        case 'PLAYING':
                            this.handlePlaybackState('playing');
                            break;
                        case 'PAUSED':
                            this.handlePlaybackState('paused');
                            break;
                        case 'IDLE':
                            this.handlePlayerIdle({ idleReason: event.mediaStatus.idleReason });
                            break;
                        case 'BUFFERING':
                            this.updateStatus('Buffering...', 'loading');
                            break;
                    }

                    // Update queue index if available
                    if (event.mediaStatus.currentItemIndex !== undefined) {
                        const newIndex = event.mediaStatus.currentItemIndex;
                        if (newIndex !== this.currentQueueIndex) {
                            this.currentQueueIndex = newIndex;
                            this.updateChapterDisplay();
                        }
                    }
                }
            }

            handleMediaInformationChanged(event) {
                this.log('üì± Media information changed', 'info');

                const mediaInfo = this.playerManager.getMediaInformation();
                if (mediaInfo) {
                    this.updateMediaDisplay(mediaInfo);
                    this.extractChapterData(mediaInfo);
                }
            }

            handleError(errorEvent) {
                const error = errorEvent.detailedErrorCode || errorEvent.error;
                this.log(`‚ùå Player error: ${JSON.stringify(error)}`, 'error');
                this.updateStatus(`Error: ${error}`, 'error');

                // Provide helpful error messages
                if (typeof error === 'number') {
                    const errorMessages = {
                        905: 'Content URL not accessible',
                        900: 'Invalid player state',
                        910: 'Load interrupted',
                        920: 'Load timeout'
                    };

                    const message = errorMessages[error] || `Unknown error code: ${error}`;
                    this.log(`üö´ Error ${error}: ${message}`, 'error');
                }
            }

            updateMediaDisplay(mediaInfo) {
                if (!mediaInfo || !mediaInfo.metadata) return;

                const title = this.bookMetadata.title || mediaInfo.metadata.title || 'Unknown Title';
                const author = this.bookMetadata.author || mediaInfo.metadata.artist || 'Unknown Author';

                document.getElementById('book-title').textContent = title;
                document.getElementById('book-author').textContent = author;

                // Update cover art
                const coverUrl = this.bookMetadata.coverUrl || mediaInfo.metadata.images?.[0]?.url;
                const coverDiv = document.getElementById('cover-art');

                if (coverUrl) {
                    coverDiv.innerHTML = `<img src="${coverUrl}" alt="Book Cover" onerror="this.parentElement.innerHTML='<div class=\\"placeholder material-icons\\">book</div>'">`;
                } else {
                    coverDiv.innerHTML = '<div class="placeholder material-icons">book</div>';
                }

                this.updateCurrentChapterTitle();
            }

            updateCurrentChapterTitle() {
                const chapterTitle = this.chapterData.chapterTitle || `Chapter ${this.currentQueueIndex + 1}`;
                document.getElementById('chapter-title').textContent = chapterTitle;
            }

            updateChapterDisplay() {
                // Update chapter highlighting
                const chapterItems = document.querySelectorAll('.chapter-item');
                chapterItems.forEach((item, index) => {
                    item.classList.toggle('current', index === this.currentQueueIndex);
                });

                // Scroll current chapter into view
                const currentChapter = document.querySelector('.chapter-item.current');
                if (currentChapter) {
                    currentChapter.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            updateProgressBars() {
                if (!this.playerManager) return;

                const currentTime = this.playerManager.getCurrentTimeSec() || 0;
                const duration = this.playerManager.getDurationSec() || 0;

                // Check if we need to handle chapter boundaries
                this.checkChapterBoundaries(currentTime);

                // Calculate chapter-specific progress
                let chapterCurrentTime = currentTime;
                let chapterDuration = duration;

                // If this is a chapter with custom boundaries, adjust the display
                if (this.chapterData.isChapter &&
                    this.chapterData.startMs !== undefined &&
                    this.chapterData.endMs !== undefined) {

                    const chapterStartSec = this.chapterData.startMs / 1000;
                    const chapterEndSec = this.chapterData.endMs / 1000;

                    chapterCurrentTime = Math.max(0, currentTime - chapterStartSec);
                    chapterDuration = chapterEndSec - chapterStartSec;

                    // Ensure we don't go beyond chapter end
                    chapterCurrentTime = Math.min(chapterCurrentTime, chapterDuration);
                }

                // Chapter Progress
                if (chapterDuration > 0) {
                    const chapterProgress = (chapterCurrentTime / chapterDuration) * 100;
                    document.getElementById('chapter-progress-fill').style.width = `${chapterProgress}%`;
                    document.getElementById('chapter-progress-text').textContent = `${Math.round(chapterProgress)}%`;
                }

                document.getElementById('chapter-current-time').textContent = this.formatTime(chapterCurrentTime);
                document.getElementById('chapter-duration').textContent = this.formatTime(chapterDuration);

                // Book Progress (using absolute timeline)
                if (this.mediaQueue.length > 0 && this.chapterStartTimes && this.totalBookDurationMs > 0) {
                    // Calculate absolute book position
                    const currentChapterStartMs = this.chapterStartTimes[this.currentQueueIndex] || 0;
                    const absoluteTimeMs = currentChapterStartMs + (chapterCurrentTime * 1000);
                    this.absoluteTimelineMs = absoluteTimeMs; // Update our tracking

                    // Book progress based on absolute timeline
                    const bookProgress = Math.min(100, (absoluteTimeMs / this.totalBookDurationMs) * 100);

                    document.getElementById('book-progress-fill').style.width = `${bookProgress}%`;
                    document.getElementById('book-progress-text').textContent = `${Math.round(bookProgress)}%`;

                    // Use actual calculated durations
                    document.getElementById('book-current-time').textContent = this.formatTime(absoluteTimeMs / 1000);
                    document.getElementById('book-duration').textContent = this.formatTime(this.totalBookDurationMs / 1000);

                    // Log absolute position for debugging Android sync
                    if (Math.floor(absoluteTimeMs / 1000) % 30 === 0) { // Log every 30 seconds
                        this.log(`üìä Absolute book position: ${Math.round(absoluteTimeMs / 1000)}s / ${Math.round(this.totalBookDurationMs / 1000)}s (${Math.round(bookProgress)}%)`, 'info');
                    }
                }
            }

            checkChapterBoundaries(currentTime) {
                // Check if we've reached the end of the current chapter
                if (this.chapterData.isChapter &&
                    this.chapterData.endMs !== undefined &&
                    currentTime >= (this.chapterData.endMs / 1000)) {

                    this.log(`üîö Reached end of chapter at ${currentTime}s (chapter ends at ${this.chapterData.endMs / 1000}s)`, 'info');

                    // Move to next chapter if available
                    if (this.currentQueueIndex < this.mediaQueue.length - 1) {
                        this.log(`‚è≠Ô∏è Auto-advancing to next chapter`, 'info');
                        this.jumpToChapter(this.currentQueueIndex + 1);
                    } else {
                        this.log(`üèÅ Reached end of book`, 'info');
                        this.playerManager.stop();
                    }
                }
            }

            updateStatus(message, type = 'info') {
                const statusChip = document.getElementById('status-chip');
                const statusText = document.getElementById('status-text');

                statusText.textContent = message;
                statusChip.className = `status-chip ${type}`;

                // Update icon based on status
                const iconMap = {
                    'playing': 'play_arrow',
                    'paused': 'pause',
                    'loading': 'hourglass_empty',
                    'error': 'error',
                    'info': 'cast'
                };

                const icon = statusChip.querySelector('.material-icons');
                icon.textContent = iconMap[type] || 'cast';
            }

            startProgressUpdates() {
                this.stopProgressUpdates();
                this.progressInterval = setInterval(() => this.updateProgressBars(), 1000);
            }

            stopProgressUpdates() {
                if (this.progressInterval) {
                    clearInterval(this.progressInterval);
                    this.progressInterval = null;
                }
            }

            formatTime(seconds) {
                if (!seconds || isNaN(seconds)) return '0:00:00';
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            formatDuration(seconds) {
                if (!seconds || isNaN(seconds)) return '0:00';
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);

                if (hours > 0) {
                    return `${hours}h ${minutes}m`;
                } else {
                    return `${minutes}m`;
                }
            }

            log(message, type = 'info') {
                const debugLog = document.getElementById('debug-log');
                const timestamp = new Date().toLocaleTimeString();

                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;

                debugLog.appendChild(logEntry);
                debugLog.scrollTop = debugLog.scrollHeight;

                // Limit log entries to prevent memory issues
                while (debugLog.children.length > 100) {
                    debugLog.removeChild(debugLog.firstChild);
                }
            }
        }

        // Debug Panel Toggle
        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const icon = document.getElementById('debug-toggle-icon');
            const receiver = window.audiobookReceiver;

            receiver.debugCollapsed = !receiver.debugCollapsed;
            panel.classList.toggle('collapsed', receiver.debugCollapsed);
            icon.textContent = receiver.debugCollapsed ? 'expand_less' : 'expand_more';
        }

        // Function to wait for Cast framework to be ready
        function waitForCastFramework(callback, maxAttempts = 50) {
            let attempts = 0;

            function checkFramework() {
                attempts++;

                if (typeof cast !== 'undefined' &&
                    cast.framework &&
                    cast.framework.CastReceiverContext &&
                    cast.framework.events &&
                    cast.framework.events.EventType) {
                    callback();
                } else if (attempts < maxAttempts) {
                    setTimeout(checkFramework, 100);
                } else {
                    console.error('Cast framework failed to load after', maxAttempts * 100, 'ms');
                    // Try to initialize anyway in case some parts work
                    callback();
                }
            }

            checkFramework();
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            waitForCastFramework(() => {
                window.audiobookReceiver = new AudiobookCastReceiver();
            });
        });

        // Handle unhandled errors
        window.addEventListener('error', (event) => {
            if (window.audiobookReceiver) {
                window.audiobookReceiver.log(`üí• JavaScript error: ${event.error?.message || event.message}`, 'error');
                window.audiobookReceiver.updateStatus('JavaScript Error', 'error');
            }
        });
    </script>
</body>
</html>